# 0x01 Application Architecture History

* 单一应用架构

早期的互联网流量很小，网站所有的功能都部署到一处。缺点：耦合度高，不易维护和扩展

* 垂直应用架构

随着访问量的增大，需要将应用拆分成不相干的几个应用以提高效率，如将一个电商项目分为电商交易系统、后台管理系统、CMS管理系统。缺点：各系统相互独立，无法互相调用，存在重叠的业务导致重复开发，后期维护困难

* 分布式服务架构

将系统拆分为服务层和表现层。服务层封装了具体的业务逻辑供表现层调用，表现层则负责处理与页面的交互操作。优点：将重复的业务代码抽象出来，提高代码复用性。缺点：调用关系变得复杂

* SOA应用架构

SOA是一种面向服务的架构，基于分布式架构。增加了一个统一的调度中心来对集群进行实时管理。单点登录（SSO）是一个典型的面向服务的架构，用户服务和认证服务被剥离开来，各个系统之间通过统一登录和管理用户信息

# 0x02 What Is RPC

从上面的应用架构发展史可以看出，RPC是分布式服务架构的关键。

**RPC**（ `Remote Procedure Call`）—远程过程调用 ，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。其实现了像调用本地类方法那样来调用服务端的服务。

**RPC 采用客户端（服务调用方）/服务器端（服务提供方）模式**，客户端只需要引入要使用的接口，接口的实现和运行都在服务器端。RPC的主要依赖技术包括**序列化、反序列化、数据传输协议**。

RMI（`Remote Method Invoke`，远程方法调用）是RPC的一种实现。RMI 的代理模式是通过代理对象将方法传递给实际对象的。`stub`驻留客户端，承担着代理远程对象实现者的角色。`skeleton/server stub`类帮助远程对象与`stub`连接进行通信。 

![image-20230406150930467](../.gitbook/assets/image-20230406150930467.png)

1. 服务调用方（client）调用以本地调用方式调用服务
2. `client stub` 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体
3. `client stub` 找到服务地址，并将消息发送到服务端
4. `server stub` 收到消息后进行解码
5. `server stub` 根据解码结果调用本地的服务
6. 本地服务执行并将结果返回给 `server stub`
7. `server stub` 将返回结果打包成消息并发送至调用方
8. `client stub` 接收到消息，并进行解码
9. 服务调用方得到最终结果

接口实现是由服务端对定义好的业务接口进行功能实现，并将接口实例注册到服务中心提供给客户端调用。

# 0x03 RPC Framework

Java中常见的RPC框架有RMI（JDK自带）、Hessian、Dubbo、Thrift

